import os
import pandas as pd
import torch

# 2.3、线性代数
# 标量：如果你曾经在餐厅支付餐费，那么应该已经知道一些基本的线性代数，比如在数字间相加或相乘。 例如，北京的温度为
# 52华氏温度（华氏度，除摄氏度外的另一种温度计量单位）。 严格来说，仅包含一个数值被称为标量（scalar）
# 例子，打印结果：(tensor(5.), tensor(6.), tensor(1.5000), tensor(9.))
# x = torch.tensor(3.0)
# y = torch.tensor(2.0)
# x + y, x * y, x / y, x**y

# 向量：向量可以被视为标量值组成的列表。通过一维张量表示向量。一般来说，张量可以具有任意长度，取决于机器的内存限制。
# 例子，打印结果：tensor([0, 1, 2, 3])
# x = torch.arange(4)
# x

# 矩阵：正如向量将标量从零阶推广到一阶，矩阵将向量从一阶推广到二阶。 
# 矩阵，我们通常用粗体、大写字母来表示 （例如XYZ， 在代码中表示为具有两个轴的张量。
# 当矩阵具有相同数量的行和列时，其形状将变为正方形； 因此，它被称为方阵（square matrix）。
# 例子，打印结果：
# tensor([[ 0,  1,  2,  3],
#         [ 4,  5,  6,  7],
#         [ 8,  9, 10, 11],
#         [12, 13, 14, 15],
#         [16, 17, 18, 19]])
# A = torch.arange(20).reshape(5, 4)
# A

# 2.3.1、张量算法的基本性质
A = torch.arange(20, dtype=torch.float32).reshape(5, 4)
# 通过分配新内存，将A的一个副本分配给B
B = A.clone()  
# 2.3.1.1、向量相加，打印结果：
# (tensor([[ 0.,  1.,  2.,  3.],
#          [ 4.,  5.,  6.,  7.],
#          [ 8.,  9., 10., 11.],
#          [12., 13., 14., 15.],
#          [16., 17., 18., 19.]]),
#  tensor([[ 0.,  2.,  4.,  6.],
#          [ 8., 10., 12., 14.],
#          [16., 18., 20., 22.],
#          [24., 26., 28., 30.],
#          [32., 34., 36., 38.]]))
A, A + B
# 2.3.1.2、向量相乘，打印结果：
# tensor([[  0.,   1.,   4.,   9.],
#         [ 16.,  25.,  36.,  49.],
#         [ 64.,  81., 100., 121.],
#         [144., 169., 196., 225.],
#         [256., 289., 324., 361.]])
A * B
# 2.3.1.3、将张量乘以或加上一个标量不会改变张量的形状，其中张量的每个元素都将与标量相加或相乘。
# 打印结果：
# (tensor([[[ 2,  3,  4,  5],
#           [ 6,  7,  8,  9],
#           [10, 11, 12, 13]],

#          [[14, 15, 16, 17],
#           [18, 19, 20, 21],
#           [22, 23, 24, 25]]]),
#  torch.Size([2, 3, 4]))
a = 2
X = torch.arange(24).reshape(2, 3, 4)
a + X, (a * X).shape

# 2.3.2、降维
# 默认情况下，调用求和函数会沿所有的轴降低张量的维度，使它变为一个标量。 
# 我们还可以指定张量沿哪一个轴来通过求和降低维度。
# 以矩阵为例，为了通过求和所有行的元素来降维（轴0），可以在调用函数时指定axis=0。 
# 由于输入矩阵沿0轴降维以生成输出向量，因此输入轴0的维数在输出形状中消失。
# 打印结果：
# (tensor([0., 1., 2., 3.]), tensor(6.))
x = torch.arange(4, dtype=torch.float32)
x, x.sum()
# 打印结果：
# (tensor([40., 45., 50., 55.]), torch.Size([4]))
A_sum_axis0 = A.sum(axis=0)
A_sum_axis0, A_sum_axis0.shape
# 指定axis=1将通过汇总所有列的元素降维（轴1）。因此，输入轴1的维数在输出形状中消失。
# 打印结果：
# (tensor([ 6., 22., 38., 54., 70.]), torch.Size([5]))
A_sum_axis1 = A.sum(axis=1)
A_sum_axis1, A_sum_axis1.shape
# 沿着行和列对矩阵求和，等价于对矩阵的所有元素进行求和。
# 打印结果：
# tensor(190.)
A.sum(axis=[0, 1])
# 一个与求和相关的量是平均值（mean或average）。 我们通过将总和除以元素总数来计算平均值。 在代码中，我们可以调用函数来计算任意形状张量的平均值。
# (tensor(9.5000), tensor(9.5000))
A.mean(), A.sum() / A.numel()
# 同样，计算平均值的函数也可以沿指定轴降低张量的维度。
# 打印结果：
# (tensor([ 8.,  9., 10., 11.]), tensor([ 8.,  9., 10., 11.]))
A.mean(axis=0), A.sum(axis=0) / A.shape[0]

# 2.3.3、非降维求和
# 有时在调用函数来计算总和或均值时保持轴数不变会很有用。
# 打印结果：
# tensor([[ 6.],
#         [22.],
#         [38.],
#         [54.],
#         [70.]])
sum_A = A.sum(axis=1, keepdims=True)
sum_A
# 由于sum_A在对每行进行求和后仍保持两个轴，我们可以通过广播将A除以sum_A。
# 打印结果：
# tensor([[0.0000, 0.1667, 0.3333, 0.5000],
#         [0.1818, 0.2273, 0.2727, 0.3182],
#         [0.2105, 0.2368, 0.2632, 0.2895],
#         [0.2222, 0.2407, 0.2593, 0.2778],
#         [0.2286, 0.2429, 0.2571, 0.2714]])
A / sum_A
# 如果我们想沿某个轴计算A元素的累积总和，
# 比如axis=0（按行计算），可以调用cumsum函数。 此函数不会沿任何轴降低输入张量的维度。
# 打印结果：
# tensor([[ 0.,  1.,  2.,  3.],
#         [ 4.,  6.,  8., 10.],
#         [12., 15., 18., 21.],
#         [24., 28., 32., 36.],
#         [40., 45., 50., 55.]])
A.cumsum(axis=0)

# 2.3.4、点积
# 给定两个向量，它们的点积是相同位置的按元素乘积的和
y = torch.ones(4, dtype = torch.float32)
x, y, torch.dot(x, y)
# 打印结果：
# (tensor([0., 1., 2., 3.]), tensor([1., 1., 1., 1.]), tensor(6.))
# 也可以通过执行按元素乘法，然后进行求和来表示两个向量的点积：
# 打印结果：
# tensor(6.)
torch.sum(x * y)

# 2.3.5、矩阵-向量积
# 在代码中使用张量表示矩阵-向量积，我们使用mv函数。 
# 当我们为矩阵A和向量x调用torch.mv(A, x)时，会执行矩阵-向量积。 
# 注意，A的列维数（沿轴1的长度）必须与x的维数（其长度）相同。
# 打印结果：
# (torch.Size([5, 4]), torch.Size([4]), tensor([ 14.,  38.,  62.,  86., 110.]))
A.shape, x.shape, torch.mv(A, x)

# 2.3.6、矩阵-矩阵乘法
# 打印结果：
# tensor([[15, 18, 21],
#         [33, 40, 47],
#         [51, 62, 73]])
AA = torch.tensor([[1, 2],
              [3, 4],
              [5, 6]])
BB = torch.tensor([[3, 4, 5],
              [6, 7, 8]])
print(torch.mm(AA, BB))

# 2.3.7、范数
# 在深度学习中，我们经常试图解决优化问题： 最大化分配给观测数据的概率; 最小化预测和真实观测之间的距离。 
# 用向量表示物品（如单词、产品或新闻文章），以便最小化相似项目之间的距离，最大化不同项目之间的距离。 
# 目标，或许是深度学习算法最重要的组成部分（除了数据），通常被表达为范数。
# 非正式地说，向量的范数是表示一个向量有多大。 这里考虑的大小（size）概念不涉及维度，而是分量的大小。
u = torch.tensor([3.0, -4.0])
print(u)
# Lp范数，L2范数：即欧几里得范数，常用于计算向量的长度或两点之间的距离。
# 打印结果：tensor(5.)
print(torch.norm(u))
# Lp范数，L1范数：也叫曼哈顿范数或出租车范数，它表示向量各元素绝对值之和。
# 打印结果：tensor(7.)
print(torch.abs(u).sum())
# 矩阵范数，Frobenius 范数，是矩阵所有元素平方和的平方根
# 打印结果：tensor(6.)
print(torch.norm(torch.ones((4, 9))))

# 2.3.8、总结
# 标量、向量、矩阵和张量是线性代数中的基本数学对象。
# 向量泛化自标量，矩阵泛化自向量。
# 标量、向量、矩阵和张量分别具有零、一、二和任意数量的轴。
# 一个张量可以通过sum和mean沿指定的轴降低维度。
# 两个矩阵的按元素乘法被称为他们的Hadamard积。它与矩阵乘法不同。
# 在深度学习中，我们经常使用范数，如L1范数、L2范数和Frobenius范数。
# 我们可以对标量、向量、矩阵和张量执行各种操作。
